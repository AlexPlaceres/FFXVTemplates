//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: ani.bt
//   Authors: Kizari
//   Version: 1
//   Purpose: FFXV Animation Clips
//  Category: Animation
// File Mask: *.ani
//  ID Bytes: 
//   History: 
//------------------------------------------------

#include "../../Utilities/utils.bt";
#include "enums.bt";
#include "functions.bt";

local LmEPackedKeyType packedKeyType = 2;
local uint rawTypeInfos[2];
rawTypeInfos[0] = 200;
rawTypeInfos[1] = 30;
local uint frameCounter = 0;
local uint presentKeys = 0;
local uint totalKeys = 0;
local uint keyCounter = 0;
local uint rawTypeCounter = 0;
local uint numInCache = 0;
local uint elementCount = rawTypeInfos[0] + rawTypeInfos[1];
local uint threshold = 0;

/*struct RawTypeInfo
{
    LmEPackedKeyType packedKeyType;
    ushort numInCache;
    ushort poseStartBit;
    uint poseDataStartOffset;
    float decompressRangeScalar;
};*/

/*struct LmSCachedPartInfo
{
    float fromKey;
    float intervalRecip;
    uint posePartIndex;
    uint nextKeyIndex;
};*/

struct PackedKey6
{
    //Printf("Packed Key Type: %d\n", packedKeyType);
    //Printf("Packed Key Size: %d\n", GetPackedKeySize(packedKeyType));
    byte data[6];
};

struct PackedKey16
{
    //Printf("Packed Key Type: %d\n", packedKeyType);
    //Printf("Packed Key Size: %d\n", GetPackedKeySize(packedKeyType));
    byte data[16];
};

struct LmSSingleAnimFrame
{
    ubyte numKeys[3]<bgcolor=0x00ff00>;
    ubyte unknowns[((numKeys[1] << 8) + numKeys[2]) & 0xFFF]<bgcolor=0x0099ff>;
    ubyte currentKeyTimeBytes[(((numKeys[1] >> 4) + 16 * numKeys[0]) & 1) + (((numKeys[1] >> 4) + 16 * numKeys[0]) >> 1)]<bgcolor=0x00ffff>;
    Align(2);
    PackedKey6 packedKeys[(numKeys[1] >> 4) + 16 * numKeys[0]];
};

/*struct LmSSingleAnimFrame_SeedFrame
{
    ubyte numKeys[3]<bgcolor=0x00ff00>;
    //ubyte onOffBits<bgcolor=0x00ff00>;
    //ushort unknown<bgcolor=0x0000ff>;
    //byte unknowns[elementCount / 2]<bgcolor=0x0099ff>;
    local uint currentKeyTimeByteOffset = ((numKeys[1] << 8) + numKeys[2]) & 0xFFF;
    Printf("\ncurrKeyTimeByteOffset: %d", currentKeyTimeByteOffset);
    local uint packedValuesOffset = (((numKeys[1] >> 4) + 16 * numKeys[0]) & 1) + (((numKeys[1] >> 4) + 16 * numKeys[0]) >> 1);
    Printf("\npackedValuesOffset: %d", packedValuesOffset);
    ubyte unknowns[currentKeyTimeByteOffset + packedValuesOffset]<bgcolor=0x0099ff>;
    Align(2);
    //PackedKey6 packedKeys[elementCount]; 
    PackedKey6 packedKeys[unknowns[0] + unknowns[1] + unknowns[2]]; 
};

struct LmSSingleAnimFrame
{
    ubyte numKeys[3]<bgcolor=0x00ff00>;
    //ubyte onOffBits<bgcolor=0x00ff00>;
    //ubyte count2<bgcolor=0xff00aa>;
    //ubyte count3<bgcolor=0xff00aa>;
    local uint currentKeyTimeByteOffset = ((numKeys[1] << 8) + numKeys[2]) & 0xFFF;
    Printf("\n\ncurrKeyTimeByteOffset: %d", currentKeyTimeByteOffset);
    local uint packedValuesOffset = (((numKeys[1] >> 4) + 16 * numKeys[0]) & 1) + (((numKeys[1] >> 4) + 16 * numKeys[0]) >> 1);
    Printf("\npackedValuesOffset: %d", packedValuesOffset);
    ubyte unknowns[currentKeyTimeByteOffset + packedValuesOffset]<bgcolor=0x0099ff>;
    local uint getBytesToAlignment = GetBytesToAlignment(2);
    Align(2);

    totalKeys = 0;
    presentKeys = 0;

    //if (getBytesToAlignment != 1 || frameCounter == 5)
    if (false)
    {
        keyCounter = 1;
    }
    else
    {
        keyCounter = 0;
    }
    rawTypeCounter = 0;
    numInCache = rawTypeInfos[0];

    do
    {
        totalKeys += unknowns[keyCounter];
        presentKeys += unknowns[keyCounter];
        keyCounter++;

        if (totalKeys >= numInCache)
        {
            rawTypeCounter++;
            if (rawTypeCounter >= 2)
            {
                Printf("\nbreak");
                break;
            }
            numInCache += rawTypeInfos[rawTypeCounter];
            Printf("\ncontinue");
            continue;
        }

        totalKeys += unknowns[keyCounter];
        keyCounter++;
    }
    while (totalKeys < numInCache);

    if (false)
    //if (getBytesToAlignment != 1 || frameCounter == 5)
    {
        presentKeys += unknowns[keyCounter];
    }
    
    Printf("\nkeyCounter: %d", keyCounter);
    Printf("\npresentKeys: %d", presentKeys);
    //PackedKey6 packedKeys[presentKeys];
    PackedKey6 packedKeys[(numKeys[1] >> 4) + 16 * numKeys[0]];

    frameCounter++;
};*/

/*struct LmSSingleAnimFrame
{
    ubyte numKeys[3]<bgcolor=0x00ff00>;
    local uint onOffBitsOffset = FTell();
    ubyte onOffBits<bgcolor=0x00ff00>;

    //if (frameCounter < 1)
    //{
        ushort unknown<bgcolor=0x0000ff>;
        //byte unknowns[((numKeys[1] >> 4) + 16 * numKeys[0]) / 2]<bgcolor=0x0099ff>;
        byte unknowns[(elementCount / 2) + (2 * frameCounter)]<bgcolor=0x0099ff>;
        Align(2);
    //}

    //local uint returnAddress = FTell();
    //FSeek(onOffBitsOffset + (frameCounter * 2));
    frameCounter++;
    //ubyte keyCount;
    //FSeek(returnAddress);

    PackedKey6 packedKeys[onOffBits];

    //ushort skipTwoBytes<bgcolor=0x0000ff>;   // As seen in SeedCacheForTimeZero
    //uint64 skipEightBytes<bgcolor=0x0000ff>; // As seen in UnpackArrayValues
    //local int supportedRawTypesCount = 4;    // This comes from the AMDL
    //PackedKey packedKeys[supportedRawTypesCount * onOffBits]; // The 62 is hardcoded for now
    //PackedKey packedKeys[onOffBits]<optimize=false>;
    //PadRecursively();
    local int offset = (((numKeys[1] << 8) + numKeys[2]) & 0xFFF);
    Printf("offset: %d\n", offset);
    FSeek(FTell() + offset - 1);
    byte currentKeyTimeByte;
    local int offset2 = (((numKeys[1] >> 4) + 16 * numKeys[0]) & 1);
    Printf("offset2: %d\n", offset2);
    local int offset3 = (((numKeys[1] >> 4) + 16 * numKeys[0]) >> 1);
    Printf("offset3: %d\n", offset3);
    FSeek(FTell() + offset2 + offset3 - 1);
    //PackedKey packedKeys[onOffBits * anim.cacheTypesCount]<optimize=false>;
};*/

struct LmSAnimFrameChunkInfo
{
    ushort lastFrameStartOffsets[16];
};

struct LmSAnimTriggerData
{
    uint16 triggerFrame;
    uint16 typeAndMirror;
    LmETriggerTrackType trackType;
    int16 customDataIndex;
};

struct LmSCustomUserDataIndexNode
{
    uint64 dataOffset; // This is the offset from the position before this value to where the data begins
    LmEAnimCustomDataType type;
    Align(8);

    /*if (type == eCustomUserDataType_BlackTriggerData)
    {
        uint unknown[10];
        LmEPackedKeyType type;
        //packedKeyType = type;
        uint unknown2;
        string uri;
    }*/
};

struct PartsSizeBlock
{
    //uint unknown[6];
    uint64 unknown;
};

struct LmAnimation
{
    float durationSeconds;
    int id;
    LmEAnimPropertyBits properties;
    uint keyframeFPS;
    float version;
    uint cacheTypesCount;
    uint partsSizeBlocksCount;
    short usersCount;
    short playCount;

    uint64 constantDataOffset;
    uint64 frameDataChunkStartPointerArrayOffset;
    uint64 animationFrameChunkInformationPointerArrayOffset;
    uint64 frameDataOffset;
    uint64 seedFrameOffset;
    uint64 unpackConstantsOffset;
    uint64 customUserDataIndexOffset;

    uint customUserDataCount;
    uint triggerCount;

    LmSAnimTriggerData triggers[triggerCount]<bgcolor=0x00ffff>;
    //local uint populationCount1 = GetBitsetPopulationCount(anim.partsSizeBlocksCount, FTell());
    PartsSizeBlock partsSizeBlocks[partsSizeBlocksCount]<bgcolor=0xff00aa>;
    //local uint populationCount2 = GetBitsetPopulationCount(anim.partsSizeBlocksCount, FTell());
    //elementCount = populationCount1 - populationCount2;
    //Printf("Element Count: %d\n", elementCount);
    PartsSizeBlock partsSizeBlocks2[partsSizeBlocksCount]<bgcolor=0x00ffff>;
    PartsSizeBlock partsSizeBlocks3[partsSizeBlocksCount]<bgcolor=0xff00aa>;

    local float count = (durationSeconds * keyframeFPS) + 1;
    local int chunkCount = (count / 16) + 1;
    
    FSeek(frameDataChunkStartPointerArrayOffset);
    uint64 frameDataChunkOffsets[chunkCount];
    FSeek(unpackConstantsOffset);
    float unpackConstants[cacheTypesCount]<bgcolor=0xff0000>;
    float maybeDecompressRangeScalar<bgcolor=0xff0000>; // Will sometimes be NaN

    local uint customDataSize = frameDataOffset - FTell();
    byte customData[customDataSize]<bgcolor=0x0000ff>;
};

//------------------------------------------------

LmAnimation anim<bgcolor=0xffff00>;

local uint returnAddress = FTell();
FSeek(anim.customUserDataIndexOffset);
LmSCustomUserDataIndexNode customUserDataIndexNodes[anim.customUserDataCount]<bgcolor=0xff00aa>;
FSeek(returnAddress);

//byte keyData[16 * elementCount]<bgcolor=0xccccff>;
//Printf("numInCache: %d", );

//LmSSingleAnimFrame frames[26]<bgcolor=0xccccff, optimize=false>;

if (anim.animationFrameChunkInformationPointerArrayOffset > 0)
{
    FSeek(anim.animationFrameChunkInformationPointerArrayOffset);
    LmSAnimFrameChunkInfo frameChunkInfo<bgcolor=0xff0000>;
}

//LmSSingleAnimFrame_SeedFrame firstFrame<bgcolor=0xaaaaff>;
//LmSSingleAnimFrame_SeedFrame secondFrame<bgcolor=0xaaaaff>;
LmSSingleAnimFrame frames[Ceil(anim.durationSeconds * anim.keyframeFPS) + 1]<bgcolor=0xaaaaff, optimize=false>;

FSeek(anim.seedFrameOffset);
LmSSingleAnimFrame seedFrame<bgcolor=0xff0000>;

struct Chunk
{
    byte chunk[size]<bgcolor=0x00ffff>;
};

/*local int count = (anim.durationSeconds * anim.keyframeFPS) + 0.001;
local int chunkCount = (count / 16) + 1;
local int i = 0;
local int size = 0;
for (i = 0; i < chunkCount; i++)
{
    FSeek(anim.frameDataChunkOffsets[i]);
    if (i < chunkCount - 1)
    {
        size = anim.frameDataChunkOffsets[i + 1] - anim.frameDataChunkOffsets[i];
    }
    else
    {
        size = anim.seedFrameOffset - anim.frameDataChunkOffsets[i];
    }
    Chunk chunk;
}*/